# 7.4. Abstract Classes

An **abstract class** is a class that cannot be instantiated and may contain abstract methods (methods without implementation). It serves as a blueprint for other classes.

## Abstract Class Syntax

```java
// Abstract class declaration
abstract class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }

    // Abstract method (no implementation)
    public abstract void makeSound();

    // Concrete method (with implementation)
    public void sleep() {
        System.out.println(name + " is sleeping");
    }

    // Can have fields
    public String getName() {
        return name;
    }
}
```

## Implementing Abstract Classes

```java
class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    // Must implement all abstract methods
    @Override
    public void makeSound() {
        System.out.println(name + " barks: Woof! Woof!");
    }
}

class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println(name + " meows: Meow! Meow!");
    }

    // Can override concrete methods
    @Override
    public void sleep() {
        System.out.println(name + " is sleeping curled up");
    }
}
```

## Complete Abstract Class Example

```java
abstract class Shape {
    protected String color;

    public Shape(String color) {
        this.color = color;
    }

    // Abstract methods
    public abstract double getArea();
    public abstract double getPerimeter();

    // Concrete method
    public void displayInfo() {
        System.out.println("Color: " + color);
        System.out.println("Area: " + getArea());
        System.out.println("Perimeter: " + getPerimeter());
    }

    // Can have static methods
    public static void printShapeType() {
        System.out.println("This is a shape");
    }
}

class Circle extends Shape {
    private double radius;

    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
}

class Rectangle extends Shape {
    private double width, height;

    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }

    @Override
    public double getArea() {
        return width * height;
    }

    @Override
    public double getPerimeter() {
        return 2 * (width + height);
    }
}
```

## Abstract Class with Constructors

```java
abstract class Vehicle {
    protected String brand;
    protected int year;

    // Abstract class can have constructors
    public Vehicle(String brand, int year) {
        this.brand = brand;
        this.year = year;
    }

    public abstract void start();
    public abstract void stop();

    // Concrete method
    public void displayInfo() {
        System.out.println("Brand: " + brand + ", Year: " + year);
    }
}

class Car extends Vehicle {
    public Car(String brand, int year) {
        super(brand, year);
    }

    @Override
    public void start() {
        System.out.println("Car is starting with key");
    }

    @Override
    public void stop() {
        System.out.println("Car is stopping");
    }
}

class ElectricCar extends Car {
    public ElectricCar(String brand, int year) {
        super(brand, year);
    }

    @Override
    public void start() {
        System.out.println("Electric car is starting silently");
    }
}
```

## Abstract Class Rules

1. **Cannot be instantiated** directly
2. **Can have abstract and concrete methods**
3. **Can have constructors** (called by subclasses)
4. **Can have fields** and static methods
5. **Subclasses must implement** all abstract methods (unless also abstract)

## When to Use Abstract Classes

1. **Share common code** among related classes
2. **Define common interface** with partial implementation
3. **Declare non-static fields** to be inherited
4. **Provide template methods** with some steps implemented
